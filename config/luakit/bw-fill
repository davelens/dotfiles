#!/usr/bin/env bash

# Helper script for luakit's Bitwarden integration.
# Looks up credentials for a domain and outputs username and password
# on separate lines.
#
# Usage: bw-fill <domain>
#
# Requires BW_SESSION to be set in the environment. If not set, opens a
# foot terminal to prompt for the master password and unlock/login.
# The session token is cached in $XDG_RUNTIME_DIR/bw-session for
# subsequent lookups within the same boot.

set -euo pipefail

domain="$1"
session_file="${XDG_RUNTIME_DIR:-/tmp}/bw-session"

get_session() {
  # Try environment first.
  if [[ -n "${BW_SESSION:-}" ]]; then
    echo "$BW_SESSION"
    return
  fi

  # Try cached session file.
  if [[ -f "$session_file" ]]; then
    local token
    token=$(<"$session_file")
    if [[ -n "$token" ]] && bw unlock --check --session "$token" &>/dev/null; then
      echo "$token"
      return
    fi
  fi

  # No valid session; prompt via foot terminal.
  local token_file prompt_script bw_status
  token_file=$(mktemp)
  prompt_script=$(mktemp)
  chmod +x "$prompt_script"
  bw_status=$(bw status 2>/dev/null | jq -r '.status // "unauthenticated"')

  # bw's Node.js inquirer crashes when stdin isn't a TTY. The workaround is
  # to feed stdin from /dev/null (prevents inquirer from opening) and pass
  # the password via --passwordenv. We prompt with `read` ourselves.
  if [[ "$bw_status" == "unauthenticated" ]]; then
    cat > "$prompt_script" << 'SCRIPT'
#!/usr/bin/env bash
err_file=$(mktemp)
read -rp "Email: " email
read -rsp "Master password: " password
echo
echo "Logging in..."
export BW_PW="$password"
unset password
bw login "$email" --passwordenv BW_PW --raw > TOKEN_FILE 2>"$err_file" < /dev/null
rc=$?
unset BW_PW
if [[ $rc -eq 0 ]] && [[ -s TOKEN_FILE ]]; then
  echo "Logged in. Syncing vault (this may take a moment)..."
  bw sync --session "$(< TOKEN_FILE)" 2>/dev/null < /dev/null
  echo "Sync complete."
else
  cat "$err_file"
  echo
  echo "Login failed. Press enter to close."
  read -r
fi
rm -f "$err_file"
SCRIPT
    sed -i "s|TOKEN_FILE|$token_file|g" "$prompt_script"
  else
    cat > "$prompt_script" << 'SCRIPT'
#!/usr/bin/env bash
err_file=$(mktemp)
read -rsp "Master password: " password
echo
echo "Unlocking..."
export BW_PW="$password"
unset password
bw unlock --passwordenv BW_PW --raw > TOKEN_FILE 2>"$err_file" < /dev/null
rc=$?
unset BW_PW
if [[ $rc -eq 0 ]] && [[ -s TOKEN_FILE ]]; then
  echo "Unlocked."
else
  cat "$err_file"
  echo
  echo "Unlock failed. Press enter to close."
  read -r
fi
rm -f "$err_file"
SCRIPT
    sed -i "s|TOKEN_FILE|$token_file|g" "$prompt_script"
  fi

  foot --title "Bitwarden" -- "$prompt_script"
  rm -f "$prompt_script"

  if [[ -s "$token_file" ]]; then
    local token
    token=$(<"$token_file")
    rm -f "$token_file"

    # Validate that what we got looks like a token (not an error message).
    if [[ ${#token} -lt 10 ]] || [[ "$token" == *"error"* ]]; then
      exit 1
    fi

    echo "$token" > "$session_file"
    chmod 600 "$session_file"
    echo "$token"
  else
    rm -f "$token_file"
    exit 1
  fi
}

session=$(get_session)

# Look up items matching this domain. Sync first if the vault is empty.
result=$(bw list items --url "https://$domain" --session "$session" 2>/dev/null || true)

if [[ -z "$result" || "$result" == "[]" ]]; then
  # Try without https:// prefix in case the vault stores bare domains.
  result=$(bw list items --url "$domain" --session "$session" 2>/dev/null || true)
fi

if [[ -z "$result" || "$result" == "[]" ]]; then
  exit 1
fi

count=$(echo "$result" | jq 'length')

if [[ "$count" -eq 1 ]]; then
  idx=0
else
  # Build a display list: "username (name)" for each match.
  options=$(echo "$result" | jq -r \
    'to_entries[] | "\(.key)) \(.value.login.username // "no username") â€” \(.value.name // "untitled")"')
  selected=$(echo "$options" | rofi -dmenu -i -p "Bitwarden ($domain)" -no-custom)
  if [[ -z "$selected" ]]; then
    exit 1
  fi
  idx=$(echo "$selected" | grep -o '^[0-9]*')
fi

username=$(echo "$result" | jq -r ".[$idx].login.username // empty")
password=$(echo "$result" | jq -r ".[$idx].login.password // empty")

if [[ -z "$username" || -z "$password" ]]; then
  exit 1
fi

echo "$username"
echo "$password"
