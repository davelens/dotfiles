#!/usr/bin/env ruby

unless File.exists?('config.ru')
  puts 'ERROR: You can only run this from a folder containing a Rails project.'
  return
end

require 'yaml'

def files
  files ||= Dir.glob('config/locales/*.yml')
end

# As taken from active_support/core_ext/hash/deep_merge.rb
class Hash
  # Returns a new hash with +self+ and +other_hash+ merged recursively.
  #
  #   h1 = { a: true, b: { c: [1, 2, 3] } }
  #   h2 = { a: false, b: { x: [3, 4, 5] } }
  #
  #   h1.deep_merge(h2) # => { a: false, b: { c: [1, 2, 3], x: [3, 4, 5] } }
  #
  # Like with Hash#merge in the standard library, a block can be provided
  # to merge values:
  #
  #   h1 = { a: 100, b: 200, c: { c1: 100 } }
  #   h2 = { b: 250, c: { c1: 200 } }
  #   h1.deep_merge(h2) { |key, this_val, other_val| this_val + other_val }
  #   # => { a: 100, b: 450, c: { c1: 300 } }
  def deep_merge(other_hash, &block)
    dup.deep_merge!(other_hash, &block)
  end

  # Same as +deep_merge+, but modifies +self+.
  def deep_merge!(other_hash, &block)
    merge!(other_hash) do |key, this_val, other_val|
      if this_val.is_a?(Hash) && other_val.is_a?(Hash)
        this_val.deep_merge(other_val, &block)
      elsif block_given?
        block.call(key, this_val, other_val)
      else
        other_val
      end
    end
  end
end

def deep_sort_hash(object)
  return object unless object.is_a?(Hash)
  hash = Hash.new
  object.each { |k, v| hash[k] = deep_sort_hash(v) }
  sorted = hash.sort { |a, b| a[0].to_s <=> b[0].to_s }
  hash.class[sorted]
end

files.each do |file|
  puts "[rails/clean-locales] Cleaning #{file}"
  hash = YAML.load_file(file)
  File.open(file, 'w') { |f| f.write(deep_sort_hash(hash).to_yaml) }
end
