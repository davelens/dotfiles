#!/usr/bin/env bash
set -e
[[ -f ~/.bash/commands ]] && . ~/.bash/commands

[[ -z $1 ]] && fail 'ERROR: No target directory given.'
[[ ! -d $1 ]] && fail "ERROR: Directory $1 is missing."
[[ ! -f $1/config.ru ]] && fail 'ERROR: You can only run this from a folder containing a Rails project.'
[[ ! `command -v rbenv` ]] && fail 'ERROR: No rbenv executable found. Check your $PATH or install rbenv with `brew install rbenv`.'

function copy_config() {
  src=$project_root/$1$2
  dest=$project_root/$1.yml

  read -n1 -p "Create a copy from $src? (y/n) " yn
  case $yn in
    [Yy]* ) cp $src $dest;;
    [Nn]* ) printf "\nERROR: No $dest present. Aborting.\n" && exit;;
    * ) printf "\nPlease answer `tput smul`Y`tput rmul`es or `tput smul`N`tput rmul`o.\n";;
  esac
}

function check_and_copy() {
  [[ -f $project_root/$1.yml ]] && return

  echo "WARNING: No $project_root/$1.yml present!"
  [[ -f $project_root/$1.yml.dist ]] && copy_config $1 .yml.dist
  [[ -f $project_root/$1.dist.yml ]] && copy_config $1 .dist.yml

  # We need an(y) echo here to prevent this entire script from stopping after
  # one pass of check_and_copy. I *think* this has to do with function return
  # statuses in bash. I was able to determine the root of the problem, but not
  # entirely identify it. Let me know if you know!
  #
  # More info here:
  # https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-10.html
  # https://stackoverflow.com/questions/16325548/nested-function-calls-in-bash
  # https://bash.cyberciti.biz/guide/The_exit_status_of_a_command
  # https://www.cyberciti.biz/faq/bash-get-exit-code-of-command/
  echo ""
}

project_root=$1 # So we can access it in functions.
check_and_copy 'config/database'
check_and_copy 'config/secrets'
check_and_copy 'config/udongo'
check_and_copy 'config/project'

# Expected output of the SSH command is something like:
#
#   ruby 2.4.5p335 (2018-10-18 revision 65137) [x86_64-linux]
#
# We emit the patch version and just extract this:
#
#   2.4.5
#
if [[ -e .ruby_version ]]; then
  ruby_version=cat .ruby_version
else
  declare -A ssh_credentials=$(~/.bin/rails/ssh-credentials)
  ruby_version=`ssh ${ssh_credentials[user]}@${ssh_credentials[server]} 'ruby -v' | awk '{print $2}' | sed -e 's/p.*//'`
fi

# TODO: Check if there is a Ruby with our desired version installed.
# TODO: No => Run rbenv to install the ruby version we need.

# TODO: Is bundler installed?
# TODO: No => Check the lockfile which bundler version we need, and install.

echo 'Installing gems:'
cd $project_root && bundle install

if [[ $? -gt 0 ]]; then
  echo ERROR: Gem installation failed, please review:
  printf "\n\tcd $project_root && bundle install"
else
  echo Done!
fi

cd - >/dev/null
