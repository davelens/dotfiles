#!/usr/bin/env bash
set -e

[[ -z $1 ]] && fail '[rails/bootstrap] ERROR: No target directory given.'
[[ ! -d $1 ]] && fail "[rails/bootstrap] ERROR: Directory $1 is missing."
[[ ! -f $1/config.ru ]] && fail '[rails/bootstrap] ERROR: You can only run this from a folder containing a Rails project.'

# shellcheck disable=SC2016
if ! command -v mise >/dev/null; then
  echo "[rails/bootstrap] ERROR: No mise executable found."

  if [[ $(os) == "macos" ]]; then
    fail 'Check your $PATH or install with `brew install mise`.'
  fi
fi

copy_config() {
  src=$project_root/$1$2
  dest=$project_root/$1.yml

  echo "[rails/bootstrap] WARNING: No $project_root/$1.yml present, but found a dist file."

  while true; do
    read -r -n1 -p "[rails/bootstrap] Create a copy from $src? (y/n) " yn
    printf "\n"
    case $yn in
    [Yy]*)
      cp "$src" "$dest"
      break
      ;;
    [Nn]*)
      fail "[rails/bootstrap] ERROR: No $dest present. Aborting."
      break
      ;;
    *) echo "[rails/bootstrap] Please answer $(tput smul)Y$(tput rmul)es or $(tput smul)N$(tput rmul)o." ;;
    esac
  done
}

check_and_copy() {
  [[ -f $project_root/$1.yml ]] && return
  [[ -f $project_root/$1.yml.dist ]] && copy_config "$1" .yml.dist
  [[ -f $project_root/$1.dist.yml ]] && copy_config "$1" .dist.yml
  return 0
}

project_root=$1 # So we can access it in functions.
check_and_copy 'config/database'
check_and_copy 'config/secrets'
check_and_copy 'config/udongo'
check_and_copy 'config/project'

# both asdf and mise can read .tool-versions to provide a local ruby binary.
if [[ ! -e $project_root/.tool-versions ]]; then
  # shellcheck disable=SC2155
  declare -A ssh_credentials=$(utility rails ssh-credentials "$project_root"/config/deploy.rb)
  required_ruby=$(ssh "${ssh_credentials[user]}"@"${ssh_credentials[server]}" 'ruby -v' | awk '{print $2}' | sed -e 's/p.*//')
  echo "ruby $required_ruby" >>"$project_root"/.tool-versions
fi

# Make sure the MYSQL env vars are there for projects that can handle them,
# and don't already have MYSQL_USER set.
if [[ ! -f .env ]] || [[ -f .env ]] && ! grep -q MYSQL_USER .env; then
  echo $'MYSQL_HOST=localhost\nMYSQL_USER=root\nMYSQL_PASSWORD=root' >>"$project_root"/.env
fi

# Check if the required ruby version is installed.
required_ruby=$(grep -E '^ruby ' "$project_root"/.tool-versions | awk '{print $2}')

if ! mise ls ruby | grep -q "^ruby\s*$required_ruby"; then
  echo "[rails/bootstrap] Installing Ruby $required_ruby"

  if ! mise install ruby "$required_ruby"; then
    echo "[rails/bootstrap] ERROR: Ruby installation failed, please review:"
    fail '\n\tcd %s && mise install ruby %s' "$project_root" "$required_ruby"
  fi
fi

required_bundler=$(cat "$project_root/Gemfile.lock" | tail -1 | sed -e 's/^[[:space:]]*//')

# Note that `mise exec` will proceed installing a Ruby version it does not yet
# see installed. Not an issue in this case, since that path will fail with an
# error in the code block above.
if ! mise exec ruby@"$required_ruby" -- gem list -i bundler -v "$required_bundler"; then
  if [[ ! $required_bundler =~ ^[a-zA-Z]+$ ]]; then
    if ! gem install bundler -v "$required_bundler"; then
      echo "[rails/bootstrap] ERROR: Bundler installation failed, please review:"
      fail '\n\tcd %s && gem install bundler -v %s' "$project_root" "$required_bundler"
    fi
  fi
fi

echo '[rails/bootstrap:bundler] Installing gems'
if ! cd "$project_root" || ! bundle install --quiet || ! cd - >/dev/null; then
  echo "[rails/bootstrap:bundler] ERROR: Gem installation failed, please review:"
  fail '\n\tcd %s && bundle install --quiet && cd - >/dev/null' "$project_root"
fi
