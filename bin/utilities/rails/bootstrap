#!/usr/bin/env bash
set -e

me="rails/$(basename "$0")"

###############################################################################
# Helpers
###############################################################################

copy_config() {
  local src="$project_root/${1}${2}"
  local dest="$project_root/$1.yml"

  echo "[$me] WARNING: No $project_root/$1.yml present, but found a dist file."

  while true; do
    read -r -n1 -p "[$me] Create a copy from $src? (y/n) " yn
    printf "\n"
    case $yn in
    [Yy]*)
      cp "$src" "$dest"
      break
      ;;
    [Nn]*)
      echo "[$me] ERROR: No $dest copied."
      break
      ;;
    *) echo "[$me] Please answer $(tput smul)Y$(tput rmul)es or $(tput smul)N$(tput rmul)o." ;;
    esac
  done
}

check_and_copy() {
  [[ -f $project_root/$1.yml ]] && return 0
  [[ -f $project_root/$1.yml.dist ]] && copy_config "$1" .yml.dist
  [[ -f $project_root/$1.dist.yml ]] && copy_config "$1" .dist.yml
  return 0
}

# Extract deploy_to path from Capistrano config, resolving Ruby interpolation
get_deploy_path() {
  local deploy_to application

  # Check deploy.rb first, then production.rb
  deploy_to=$(grep -E "set :deploy_to" "$project_root/config/deploy.rb" 2>/dev/null | sed -E "s/.*['\"]([^'\"]+)['\"]/\1/" | head -1) || true
  if [[ -z "$deploy_to" ]]; then
    deploy_to=$(grep -E "set :deploy_to" "$project_root/config/deploy/production.rb" 2>/dev/null | sed -E "s/.*['\"]([^'\"]+)['\"]/\1/" | head -1) || true
  fi

  # Handle Ruby interpolation: #{fetch(:application)}
  if [[ "$deploy_to" == *'#{fetch(:application)}'* ]]; then
    application=$(grep -E "set :application" "$project_root/config/deploy/production.rb" 2>/dev/null | sed -E "s/.*['\"]([^'\"]+)['\"]/\1/" | head -1) || true
    if [[ -n "$application" ]]; then
      deploy_to="${deploy_to//#\{fetch\(:application\)\}/$application}"
    fi
  fi

  echo "$deploy_to"
}

###############################################################################
# Setup steps
###############################################################################

check_dependencies() {
  # shellcheck disable=SC2016
  if ! command -v mise >/dev/null; then
    echo "[$me] ERROR: No mise executable found."
    if [[ $(os) == "macos" ]]; then
      fail 'Check your $PATH or install with `brew install mise`.'
    fi
    fail "mise is required for Ruby version management."
  fi
}

copy_dist_configs() {
  check_and_copy 'config/database'
  check_and_copy 'config/secrets'
  check_and_copy 'config/udongo'
  check_and_copy 'config/project'
}

fetch_ssh_credentials() {
  # shellcheck disable=SC2155
  declare -gA ssh_credentials=$(cd "$project_root" && utility rails ssh-credentials 2>/dev/null) || true
  ssh_target="${ssh_credentials[user]}@${ssh_credentials[server]}"
}

fetch_credential_keys() {
  local creds_dir="$project_root/config/credentials"

  # Check if there are any encrypted credentials files that need keys
  if [[ ! -d "$creds_dir" ]] && [[ ! -f "$project_root/config/credentials.yml.enc" ]]; then
    return 0
  fi

  if [[ -z "${ssh_credentials[user]}" || -z "${ssh_credentials[server]}" ]]; then
    echo "[$me] WARNING: Could not determine SSH credentials, skipping key fetch."
    return 0
  fi

  local deploy_to
  deploy_to=$(get_deploy_path)

  if [[ -z "$deploy_to" ]]; then
    echo "[$me] WARNING: Could not determine deploy path, skipping key fetch."
    return 0
  fi

  local remote_shared="$deploy_to/shared/config"

  echo "[$me] Fetching credential keys from $ssh_target..."

  # Fetch master.key if we have credentials.yml.enc but no master.key
  if [[ -f "$project_root/config/credentials.yml.enc" ]] && [[ ! -f "$project_root/config/master.key" ]]; then
    if ssh "$ssh_target" "test -f $remote_shared/master.key" 2>/dev/null; then
      scp -q "$ssh_target:$remote_shared/master.key" "$project_root/config/master.key"
      echo "[$me] Fetched config/master.key"
    fi
  fi

  # Fetch production.key from server and copy for all environments (they share the same key)
  mkdir -p "$creds_dir"
  local remote_prod_key="$remote_shared/credentials/production.key"

  if ssh "$ssh_target" "test -f $remote_prod_key" 2>/dev/null; then
    scp -q "$ssh_target:$remote_prod_key" "$creds_dir/production.key"
    echo "[$me] Fetched config/credentials/production.key"

    # Copy for other environments that need the same key
    for env in development test; do
      if [[ ! -f "$creds_dir/$env.key" ]]; then
        cp "$creds_dir/production.key" "$creds_dir/$env.key"
        echo "[$me] Created config/credentials/$env.key"
      fi
    done
  fi
}

fetch_ruby_version() {
  [[ -e "$project_root/.tool-versions" ]] && return 0

  if [[ -n "${ssh_credentials[user]}" && -n "${ssh_credentials[server]}" ]]; then
    local required_ruby
    required_ruby=$(ssh "$ssh_target" 'ruby -v' | awk '{print $2}' | sed -e 's/p.*//')
    echo "ruby $required_ruby" >>"$project_root/.tool-versions"
  else
    echo "[$me] WARNING: Could not determine SSH credentials, skipping Ruby version detection."
  fi
}

setup_mysql_env() {
  if [[ ! -f "$project_root/.env" ]] || ! grep -q MYSQL_USER "$project_root/.env"; then
    echo $'MYSQL_HOST=localhost\nMYSQL_USER=root\nMYSQL_PASSWORD=root' >>"$project_root/.env"
  fi
}

install_ruby() {
  local required_ruby
  required_ruby=$(grep -E '^ruby ' "$project_root/.tool-versions" | awk '{print $2}')

  if ! mise ls ruby | grep -q "^ruby\s*$required_ruby"; then
    echo "[$me] Installing Ruby $required_ruby"

    if ! mise install ruby "$required_ruby"; then
      echo "[$me] ERROR: Ruby installation failed, please review:"
      fail '\n\tcd %s && mise install ruby %s' "$project_root" "$required_ruby"
    fi
  fi
}

install_bundler() {
  local required_ruby required_bundler
  required_ruby=$(grep -E '^ruby ' "$project_root/.tool-versions" | awk '{print $2}')
  required_bundler=$(tail -1 "$project_root/Gemfile.lock" | sed -e 's/^[[:space:]]*//')

  # Note that `mise exec` will proceed installing a Ruby version it does not yet
  # see installed. Not an issue in this case, since that path will fail with an
  # error in install_ruby above.
  if ! mise exec ruby@"$required_ruby" -- gem list -i bundler -v "$required_bundler" >/dev/null; then
    if [[ ! $required_bundler =~ ^[a-zA-Z]+$ ]]; then
      if ! gem install bundler -v "$required_bundler"; then
        echo "[$me] ERROR: Bundler installation failed, please review:"
        fail '\n\tcd %s && gem install bundler -v %s' "$project_root" "$required_bundler"
      fi
    fi
  fi
}

install_gems() {
  echo "[$me] Installing gems"
  if ! cd "$project_root" || ! bundle install --quiet || ! cd - >/dev/null; then
    echo "[$me] ERROR: bundle install failed, please review:"
    fail '\n\tcd %s && bundle install --quiet && cd - >/dev/null' "$project_root"
  fi
}

###############################################################################
# Main
###############################################################################

main() {
  project_root="$1"

  [[ -z "$project_root" ]] && fail "[$me] ERROR: No target directory given."
  [[ ! -d "$project_root" ]] && fail "[$me] ERROR: Directory $project_root is missing."
  [[ ! -f "$project_root/config.ru" ]] && fail "[$me] ERROR: You can only run this from a folder containing a Rails project."

  check_dependencies
  copy_dist_configs
  fetch_ssh_credentials
  fetch_credential_keys
  fetch_ruby_version
  setup_mysql_env
  install_ruby
  install_bundler
  install_gems

  echo "[$me] All done!"
}

main "$@"
