#!/usr/bin/env bash
# shellcheck disable=SC2154

# Opens a tmux session with preset windows for development work on a project.
#
# Usage:
#   repo                         Fuzzy find a project in $REPO_NAMESPACE
#   repo <user>/<repo>           Open or clone a specific namespace
#   repo -n                      Search GitHub API for repos to clone
#   repo -x                      Kill a tmux session via fuzzy selection
#
# The script assumes a folder structure mirroring GitHub namespaces:
#   $REPO_NAMESPACE/<git-org-or-user>/<git-repo>
#
# Framework support is modular - see repo.d/ for available frameworks.
# To add a new framework, create a new .sh file in repo.d/ implementing
# the interface defined in repo.d/_base.sh

set -e

me="tmux/$(basename "$0")"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FRAMEWORK_DIR="$SCRIPT_DIR/repo.d"
NAMESPACE="${REPO_NAMESPACE:-$HOME/Repositories}"

###############################################################################
# Helpers
###############################################################################

usage() {
  echo
  echo "Usage: utility tmux repo [-h|--help] [-x] [-n] [<namespace>]"
  echo
  echo "Options:"
  echo "  -h|--help      Show this help message and exit."
  echo "  -x             Kill a tmux session via fuzzy selection."
  echo "  -n             Search GitHub for repos (uses GITHUB_PERSONAL_ACCESS_TOKEN)."
  echo "  <namespace>    A github namespace (e.g. 'davelens/dotfiles')."
  echo
  echo "Environment:"
  echo "  REPO_NAMESPACE   Base directory for projects (default: ~/Repositories)"
}

session_name_from_path() {
  local name="$1"
  # Dots and colons aren't allowed in tmux session names
  name="${name//./_}"
  name="${name//:/_}"
  echo "$name"
}

clone_repo() {
  local namespace="$1"
  local destination="$2"

  $print_status -i pending "Cloning $namespace..."
  if git clone "git@github.com:$namespace.git" "$destination" 2>/dev/null; then
    $print_status -i ok "Cloned $namespace"
    return 0
  else
    $print_status -i error "Failed to clone $namespace"
    return 1
  fi
}

###############################################################################
# Framework detection
###############################################################################

# Load base interface
# shellcheck source=repo.d/_base.sh
source "$FRAMEWORK_DIR/_base.sh"

# Detect framework and source appropriate module
# Returns the framework name via FRAMEWORK_NAME variable
detect_framework() {
  local path="$1"
  local priorities=()
  local files=()
  local sorted=()

  # Collect all framework files (excluding _base.sh)
  for f in "$FRAMEWORK_DIR"/*.sh; do
    [ "$(basename "$f")" == "_base.sh" ] && continue
    [ -f "$f" ] || continue
    files+=("$f")
  done

  # Sort by priority
  for f in "${files[@]}"; do
    # shellcheck source=/dev/null
    source "$f"
    priorities+=("$FRAMEWORK_PRIORITY:$f")
  done

  # Sort and test each framework
  mapfile -t sorted < <(printf '%s\n' "${priorities[@]}" | sort -t: -k1 -n)

  for entry in "${sorted[@]}"; do
    local file="${entry#*:}"
    # Unset optional functions before sourcing to prevent bleed-through
    unset -f use_minimal_windows 2>/dev/null
    # shellcheck source=/dev/null
    source "$file"
    if detect "$path"; then
      return 0
    fi
  done

  # Should not reach here if default.sh exists with priority 999
  return 1
}

###############################################################################
# Main
###############################################################################

main() {
  local target destination session bootstrap=0 start_server

  while [ $# -gt 0 ]; do
    case "$1" in
    -h | --help)
      usage && exit 0
      ;;
    -x) # Kill session via fuzzy selection
      local sessions selected
      sessions=$(tmux ls 2>/dev/null | sed 's/:.*//')
      [ -z "$sessions" ] && fail "[$me] No tmux sessions found."
      selected=$(echo "$sessions" | fzf --prompt="Kill session: ") || exit 0

      tmux kill-session -t "$selected"
      exit 0
      ;;
    -n) # Search GitHub for repos
      target="$(utility github search-repos user:davelens+user:blimp)"
      shift
      ;;
    *)
      target="$1"
      shift
      ;;
    esac
  done

  # Block nested tmux sessions
  # [ -n "$TMUX" ] && fail "[$me] Cannot create nested tmux sessions. Detach first (prefix + d)."

  # Fuzzy find if no target specified
  if [ -z "$target" ]; then
    target=$(find "$NAMESPACE" -mindepth 2 -maxdepth 2 -type d 2>/dev/null |
      sed "s|$NAMESPACE/||" |
      fzf --prompt="Select project: ") || exit 0
  fi

  [ -z "$target" ] && fail "[$me] No project selected."

  destination="$NAMESPACE/$target"

  # Clone if directory doesn't exist
  if [ ! -d "$destination" ]; then
    bootstrap=1
    clone_repo "$target" "$destination" || exit 1
  fi

  session=$(session_name_from_path "$target")

  # Attach to existing session if it exists
  if tmux has-session -t "=$session" 2>/dev/null; then
    tmux attach -t "=$session"
    exit 0
  fi

  # Detect framework and load its module
  detect_framework "$destination"

  # Get database adapter for DB startup check
  local adapter
  adapter=$(db_adapter "$destination")

  # Ensure database is running if needed
  [ -n "$adapter" ] && ensure_db_running "$adapter"

  # Bootstrap if freshly cloned
  if [ $bootstrap -eq 1 ]; then
    $print_status -i pending "Running $FRAMEWORK_NAME bootstrap..."
    bootstrap "$destination"
  fi

  # Check if framework wants minimal windows
  if type -t use_minimal_windows &>/dev/null && use_minimal_windows; then
    setup_minimal_windows "$session" "$destination"
  else
    # Ask about starting server if framework has a server
    local prompt
    prompt=$(server_prompt)
    if [ -n "$prompt" ]; then
      start_server=$($prompt_user -yn "[$me] $prompt")
    fi

    setup_standard_windows "$session" "$destination" "$start_server"
  fi

  # Attach to the session, focusing on the editor window
  tmux select-window -t "$session:editor"
  tmux attach -t "$session"
}

main "$@"
