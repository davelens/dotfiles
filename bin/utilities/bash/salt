#!/usr/bin/env bash

# I mainly made this to understand how to move the cursor around in bash.
# Turns out it's quite useful when building CLI tools.
#
# https://gist.github.com/ConnerWill/d4b6c776b509add763e17f9f113fd25b
#
NAME=$(basename "$0")

trap 'error_handler' ERR

usage() {
  echo
  echo "Usage: $NAME [-h|--help] <options>"
  echo 
  echo "Operations related to the default salt used in encrypt/decrypt."
  echo 
  echo "Commands:"
  echo "  current               (Re)generate a new salt."
  echo "  reset                 Reset the salt along with all encrypted files."
  echo
  echo "Options:"
  echo "  -h|--help             Show this help message and exit."
  #echo "  -s|--silent          Suppress feedback messages where possible."
}

# Fail early if no arguments are given.
[[ $# -eq 0 ]] && usage && exit 1

#############################################################################

cursor() { utility bash cursor "$@"; }
encrypt() { utility bash encrypt "$@"; }
decrypt() { utility bash decrypt "$@"; }
print-status() { utility bash print-status "$@"; }
prompt-user() { utility bash prompt-user "$@"; }

#############################################################################

function reset() {
  print-status "Resetting salt and all encrypted files ..."
  rm -f "$DOTFILES_STATE_PATH"/*.enc
  cursor move-up move-start
  print-status -i ok "Salt and encrypted files have been reset.\n"
  echo "    Please source ~/.bashrc (\`s\`) or restart your shell to apply changes."
  echo
}

function generate() {
  local looping passkey pass_confirmation icon
  looping=0
  icon="$(pending)"

  if [[ -n $1 ]]; then
    [[ $1 == "-l" ]] && looping=1 && shift
    passkey="$1"
  fi

  # So we know where to restore to after a variable number of attempts.
  if [[ $looping -eq 0 ]]; then
    printf "$(utility bash cursor -r save)" >&2
    print-status "Generating new salt ..." >&2
  fi

  if [[ -z "$passkey" ]]; then
    echo
    passkey=$(prompt-user -i "$icon " -m "Enter your desired password: ")
  fi

  pass_confirmation=$(prompt-user -i "$(pending) " -m  "Confirm your entered password: ")

  if [[ ${#passkey} -lt 3 ]]; then
    printf "$(utility bash cursor -r restore clear-down)" >&2
    print-status -i error "Passkey must be at least 3 characters long."
    generate -l
    return
  fi

  if [[ "$passkey" != "$pass_confirmation" ]]; then
    printf "$(utility bash cursor -r restore clear-down)" >&2
    print-status -i error "Mismatched passwords, try again."
    generate -l
    return
  fi

  salt=$(openssl rand -base64 32)
  encrypt -p $passkey -i "$salt" -o "$DOTFILES_SALT_PATH"
  printf "$(utility bash cursor -r restore clear-down)" >&2

  if [[ $? -eq 0 ]]; then
    print-status -i ok "Encrypted salt is ready."
    echo
  else
    print-status -i error "Decrypt failed; try again or press Ctrl-c to abort."
    generate -l
    return
  fi
}

function decrypt_salt() {
  local passkey icon
  [[ -n $1 ]] && passkey="$1"

  if [[ -z "$passkey" ]]; then
    icon="$(pending)"
    passkey=$(prompt-user -i "$icon " -m "Enter your salt passkey: ")
  fi

  if decrypt -p "$passkey" -f "$DOTFILES_SALT_PATH" 2>/dev/null; then
    echo "$?"
    exit 0
  else
    exit 1
  fi
}

function current() {
  exists

  case $? in
    0) echo "$DOTFILES_SALT" ;;
    1) decrypt_salt "${1:-"$passkey"}";; # Salt file exists, but env var is empty
    2) generate "${1:-"$passkey"}" ;; # No salt file found.
    *) exit 1;;
  esac

  if [[ -n "$salt" ]]; then
    echo "$salt"
    exit 0
  else
    exit 1
  fi
}

# 0 = Salt env var is set
# 1 = Salt encryption file exists but salt env var is empty.
# 2 = No salt encryption
function exists() {
  [[ -n $DOTFILES_SALT ]] && return 0
  [[ -f $DOTFILES_SALT_PATH ]] && return 1
  return 2 # No traces of a salt whatsoever
}

#############################################################################

function main() {
  local command options passkey
  options=()

  IFS=' ' read -r -a args <<< "$@"

  for arg in "${args[@]}"; do
    if [[ $arg =~ ^- ]]; then 
      case "$arg" in
        -h | --help)
          usage
          exit 0
          ;;
        -k | --passkey)
          passkey="$2" 
          ;;
        #-s | --silent) silent=1;;
        -*)
          if [[ -z $1 ]]; then
            utility bash print-status -i error "Invalid options: $arg"
            usage && exit 1
          fi
          ;;
      esac

      options+=("$arg")
    fi
  done

  # Last argument should always be the command.
  command="${@: -1}"

  if ! command -v "$command" &> /dev/null; then
    utility bash print-status -i error "Invalid command: $command"
    usage && exit 1
  fi

  $command
}

main "$@"
