#!/usr/bin/env bash

[[ -f $DOTFILES_PATH/bash/helpers.sh ]] && source $DOTFILES_PATH/bash/helpers.sh

NAME=$(basename $0)
MYTMPDIR="$(mktemp -d)"
trap 'error_handler' ERR
trap 'rm -rf -- "$MYTMPDIR"' EXIT

usage() {
  echo
  echo "Usage: $NAME [-h|--help] -i <input> -o <output>"
  echo
  echo "Options:"
  echo "  -h|--help                   Show this help message and exit."
  echo "  -i|--in <string>            Provide a value to encrypt."
  echo "  -f|--file                   Process -i as file path instead of text."
  echo "  -o|--out <file>             Write output to file"
  echo "  -p|--passphrase <string>    Provide a passphrase to encrypt with."
}

# Fail early if no arguments are given.
[[ $# -eq 0 ]] && usage && exit 1

function build_command() {
  if [[ -z $input ]]; then
    if [[ -p /dev/stdin ]]; then
      input="$(cat /dev/stdin)"
    else
      utility bash print-status -i error "You need to provide an input string to encrypt."
      usage && exit 1
    fi
  fi

  if [[ $file -eq 1 ]] && [[ ! -f $input ]]; then
    utility bash print-status -i error "Input file not found: $input"
    usage && exit 1
  fi

  local string="openssl aes-256-cbc -e -pbkdf2"

  if [[ -n "$passphrase" ]]; then
    string+=" -k '$passphrase'"
  fi

  echo $string
}

function main() {
  local command file=0 input output passphrase

  while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
      usage
      exit 0
      ;;
    -f | --file)
      file=1
      shift
      ;;
    -i | --in)
      shift
      input="$1"
      shift
      ;;
    -o | --out)
      shift
      output="$1"
      shift
      ;;
    -p | --passphrase)
      shift
      passphrase="$1"
      shift
      ;;
    *)
      if [[ -z $input ]]; then
        input="$1"
      else
        utility bash print-status -i error "Invalid option: $1"
        usage && exit 1
      fi
      shift
      ;;
    esac
  done

  command=$(build_command)

  if [[ $file -eq 0 ]]; then
    local tempfile=$(mktemp -p "$MYTMPDIR")
    printf "%s" "$input" > $tempfile
    input="$tempfile"
  fi

  command+=" -in $input"

  # No input/output file provided = always print to stdout
  if [[ -n $output ]]; then 
    command+=" -out $output"
  fi
  
  $command
}

main "$@"
