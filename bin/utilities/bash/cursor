#!/usr/bin/env bash

[[ -f $DOTFILES_PATH/bash/helpers.sh ]] && source $DOTFILES_PATH/bash/helpers.sh
trap 'error_handler' ERR

#
# Note: the [-p|--for-prompt] option is specific to my dotfiles.
# I wouldn't know how to go about calculating the bash prompt height. 
# I know in my case it's always 2.
#
# I suppose it could be a bit more flexible by reading the deficit value
# from an ENV var so you could override it globally that way, but ... meh.
#
usage() {
  echo
  echo "Usage: $(basename $0) [-h|--help] <command(s)>"
  echo 
  echo "Examples:"
  echo "  You can chain commands together:"
  echo "    $(basename $0) move-up:3 clear-line"
  echo "    $(basename $0) move-up:4 clear-line"
  echo
  echo "Commands:"
  echo "  move-start          Move cursor to the beginning of the line."
  echo "  move-end            Move cursor to EOL"
  echo "                      (EXPERIMENTAL: There is no ANSI sequence for EOL)"
  echo "  move-right<:#>      Move cursor to the right # cols."
  echo "  move-left<:#>       Move cursor to the left # cols."
  echo "  move-up<:#>         Move cursor up # lines."
  echo "  move-down<:#>       Move cursor down # lines."
  echo "  clear-down          Clear output from the cursor down."
  echo "  clear-up<:#>        Clear output from the cursor up # lines."
  echo "  clear-line          Clear output from the cursor to the end of the line."
  echo
  echo "Options:"
  echo "  -h|--help           Show this help message and exit."
  echo "  -p|--for-prompt     Accounts for the bash prompt height."
  echo "                      (Prevents some confusion with line count)."
  echo "  -r|--raw            Returns the raw string output of a command"
}

# Fail early if no arguments are given.
[[ $# -eq 0 ]] && usage && exit 1

function move_up() {
  local jump=${1:-1}
  [[ $in_prompt -eq 1 ]] && jump=$((jump + 2))
  move_start
  printf "\033[${jump}A"
}

function move_down() {
  local jump=${1:-1}
  [[ $in_prompt -eq 1 ]] && jump=$((jump - 2))
  move_start
  printf "\033[${jump}B"
}

# Forwards the cursor # columns to the right. Makes space when EOL.
function move_right() {
  local jump=${1:-1}
  printf "\033[${jump}C"
}

# Backs the cursor # columns to the left.
function move_left() {
  local jump=${1:-1}
  printf "\033[${jump}D"
}

# Returns the cursor to the beginning of the line.
function move_start() {
  printf "\033[G"
}

# There is no true ANSI end-of-line sequence, so this is the best we can do.
# 1. $(tput steps) =  Grab the current width of the terminal
# 2. \33[C =  Grab the current width of the terminal
# printf "\033[$(tput steps)\033[s\n"
function move_end() {
  move_right $(tput cols)
}

# TODO: Review what the best way is.
# printf '%.s ' $(seq 1 $(tput cols))
# printf "\r\033[K\r"
function clear_line() {
  move_start && printf "\033[K" && move_start
}

function clear_up() {
  local jump=${1:-1}
  move_up $jump
  clear_down
}

function clear_down() {
  printf "\033[J"
}

# TODO:
function clear_right() {
  local jump=${1:-1}
  printf "$jump"
}

# TODO:
function clear_left() {
  local jump=${1:-1}
  printf "$jump"
}

#############################################################################

function main() {
  local steps=1 in_prompt=0 raw=0 
  local commands=() options=()

  IFS=' ' read -r -a args <<< "$@"

  # Isolate commands from options
  for arg in "${args[@]}"; do
    if [[ $arg =~ ^- ]]; then 
      case $arg in
        -h | --help) usage && exit 0 ;;
        -p | --for-prompt) in_prompt=1;;
        -r | --raw) raw=1;;
        *)
          if [[ -z $1 ]]; then
            print-status -i error "Invalid options: $arg"
            usage && exit 1
          fi
          ;;
      esac

      options+=("$arg")
    else 
      commands+=("$arg")
    fi
  done

  # We do a first loop to catch any invalid commands first to exit early.
  # I'll take the overhead of looping a second time for command chaining.
  # Otherwise we end up with a messed up screen if we stop mid-move or clear.
  for ((i = 0; i < ${#commands[@]}; i++)); do
    commands[i]=${commands[i]/-/_}

    if ! command -v ${commands[i]%%:*} &> /dev/null; then
      print-status -i error "Invalid command: ${commands[i]}"
      usage && exit 1
    fi
  done

  chain_commands
}

function chain_commands() {
  for cmd in ${commands[@]}; do
    command="${cmd%%:*}" # Extract the part before `:`
    steps=${cmd##*:}   # Extract the part after `:`
    [[ "$command" == "$steps" ]] && steps=1
    $command $steps
  done
}

main "$@"
