#!/usr/bin/env bash

# I mainly made this to understand how to move the cursor around in bash.
# Turns out it's quite useful when building CLI tools.
#
# https://gist.github.com/ConnerWill/d4b6c776b509add763e17f9f113fd25b
#

[[ -f $DOTFILES_PATH/bash/helpers.sh ]] && source $DOTFILES_PATH/bash/helpers.sh
trap 'error_handler' ERR


NAME=$(basename $0)
#
# Note: the [-p|--for-prompt] option is specific to my dotfiles.
# I wouldn't know how to go about calculating the bash prompt height. 
# I know in my case it's always 2.
#
# I suppose it could be a bit more flexible by reading the deficit value
# from an ENV var so you could override it globally that way, but ... meh.
#
usage() {
  echo
  echo "Usage: $NAME [-h|--help] <command(s)>"
  echo 
  echo "Move the cursor around the terminal quickly by chaining commands."
  echo
  echo "Examples:"
  echo "    $NAME move-up:4 clear-line"
  echo "    $NAME line:18 clear-down"
  echo "    $NAME save line:40 col:30 print:H restore"
  echo
  echo "Notes:"
  echo "  EOL = End of Line"
  echo "  SOL = Start of Line"
  echo
  echo "Commands:"
  echo "  move-start          Move cursor to SOL."
  echo "  move-end            Move cursor to EOL"
  echo "  move-right<:#>      Move cursor to the right <#> cols."
  echo "  move-left<:#>       Move cursor to the left <#> cols."
  echo "  move-up<:#>         Move cursor up <#> lines."
  echo "  move-down<:#>       Move cursor down <#> lines."
  echo "  col:<#>             Move cursor to column <#>."
  echo "  line:<#>            Move cursor to line <#>."
  echo "  clear-down          Clear output from the cursor down."
  echo "  clear-up<:#>        Clear output from the cursor up # lines."
  echo "  clear-right         Clear output from the cursor to EOL."
  echo "  clear-left          Clear output from the cursor to SOL."
  echo "  clear-line          Clear output from the entire line."
  echo "  print:<s>           Prints <s> at the cursor's position."
  echo
  echo "Options:"
  echo "  -h|--help           Show this help message and exit."
  echo "  -p|--for-prompt     Accounts for the bash prompt height."
  echo "                      (Prevents some confusion with line count)."
  echo "  -r|--raw            Returns the ANSI escape sequence as a string."
}

# Fail early if no arguments are given.
[[ $# -eq 0 ]] && usage && exit 1

function move_up() {
  local jump=${1:-1}
  [[ $in_prompt -eq 1 ]] && jump=$((jump + 2))
  printf "\033[${jump}A"
}

function move_down() {
  local jump=${1:-1}
  [[ $in_prompt -eq 1 ]] && jump=$((jump - 2))
  printf "\033[${jump}B"
}

# Forwards the cursor # columns to the right. Makes space when EOL.
function move_right() {
  local jump=${1:-1}
  printf "\033[${jump}C"
}

# Backs the cursor # columns to the left.
function move_left() {
  local jump=${1:-1}
  printf "\033[${jump}D"
}

# Returns the cursor to the beginning of the line.
function move_start() {
  printf "\033[G"
}

# There is no true ANSI end-of-line sequence, so this is the best we can do.
function move_end() {
  move_right $(tput cols)
}

function clear_up() {
  local jump=${1:-1}
  move_up $jump
  clear_down
}

function clear_down() {
  printf "\033[0J"
}

function clear_right() {
  printf "\033[0K"
}

function clear_left() {
  printf "\033[1K"
}

function clear_line() {
  printf "\033[2K"
}

# TODO: Support for cursor position registers
function restore() {
  printf "\033[u"
}

function save() {
  printf "\033[s"
}

function col() {
  printf "\033[${steps}G"
}

# TODO: Jump to col as well
function line() {
  printf "\033[${steps};1H"
}

function print() {
  printf "$steps"
}

#############################################################################

function main() {
  local steps=1 in_prompt=0 raw=0 
  local commands=() options=()

  IFS=' ' read -r -a args <<< "$@"

  # Isolate commands from options
  for arg in "${args[@]}"; do
    if [[ $arg =~ ^- ]]; then 
      case $arg in
        -h | --help) usage && exit 0 ;;
        -p | --for-prompt) in_prompt=1;;
        -r | --raw) raw=1;;
        *)
          if [[ -z $1 ]]; then
            utility bash print-status -i error "Invalid options: $arg"
            usage && exit 1
          fi
          ;;
      esac

      options+=("$arg")
    else 
      commands+=("$arg")
    fi
  done

  # We do a first loop to catch any invalid commands first to exit early.
  # I'll take the overhead of looping a second time for command chaining.
  # Otherwise we end up with a messed up screen if we stop mid-move or clear.
  for ((i = 0; i < ${#commands[@]}; i++)); do
    commands[i]=${commands[i]/-/_}

    if ! command -v ${commands[i]%%:*} &> /dev/null; then
      utility bash print-status -i error "Invalid command: ${commands[i]}"
      usage && exit 1
    fi
  done

  chain_commands
}

function chain_commands() {
  for cmd in ${commands[@]}; do
    command="${cmd%%:*}" # Extract the part before `:`
    steps=${cmd##*:}   # Extract the part after `:`
    [[ "$command" == "$steps" ]] && steps=1
    $command $steps
  done
}

main "$@"
