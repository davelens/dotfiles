#!/usr/bin/env bash

# TODO: Would be better to switch most of my ENV vars I don't need in $PATH
# to live in a config/config.toml file or something.

# Derive the dotfiles' absolute path so we always have a sensible default for 
# the ~/.env file.
env_file="${HOME}/.env"
setup_path="$(dirname $(realpath "$0"))"
export DOTFILES_PATH=$(dirname $setup_path)
export DOTFILES_STATE_PATH="${HOME}/.local/state/dots"
bitwarden_cmd="$DOTFILES_PATH/bin/utilities/misc/bitwarden"

[[ -f $DOTFILES_PATH/bash/helpers.sh ]] && source $DOTFILES_PATH/bash/helpers.sh
trap 'clear && interrupt_handler' SIGINT

function print-status() {
  utility bash print-status "$@"
}

function prompt-user() {
  utility bash prompt-user "$@"
}

function separator() {
  printf "─│"
  printf '%.s─' $(seq 3 $(tput cols))
  utility bash cursor move-down
}

function fecho() {
  printf " │  %s\n" "$1"
}

function intro() {
  separator
  fecho
  fecho "This script will help you set up your environment variables."
  fecho "Press Enter to confirm suggested values."
  fecho "Press Ctrl + c at any time to abort."
  fecho
}

function salt_intro() {
  fecho
  separator
  fecho
  fecho "ENCRYPTION                                                         (part 1/5)"
  fecho
  fecho "Some utility commands like encrypt/decrypt require a password-protected salt."
  fecho "Once in a blue moon you shall be prompted to reset it."
  fecho
}

function secrets_management_intro() {
  separator
  fecho
  fecho "SECRETS MANAGEMENT                                                 (part 2/5)"
  fecho
  fecho "These dotfiles require access to some sensitive data, for example"
  fecho "Github (a personal access token) and GPG (your signing key) credentials."
  fecho
  fecho "These will be stored in ENV vars in $env_file."
  fecho
}

function bitwarden_intro() {
  fecho
  fecho "Support for Bitwarden, a free password manager, is built into this script."
  fecho
}

function bitwarden_data_intro() {
  fecho
  fecho "You need the following two items ready in Bitwarden:"
  fecho
  fecho "1. An item of the Identity type, containing your first and last name."
  fecho "   a. A custom field entry on the Identity item named 'GPG signing key'"
  fecho
  fecho "2. An item of the Login type, named \"Github\", containing:"
  fecho "   a. The Username login credential that matches your Github e-mail address"
  fecho "   b. A custom field entry named 'Public username'"
  fecho "   c. A custom field entry named 'Personal access token'"
  fecho 
}

function secrets_management_requirements() {
  secrets_management_intro

  if [[ -f $env_file ]]; then
    source "$env_file"
    print-status -i ok "Loaded environment variables from $env_file."
  fi

  # TODO:
  # - [ ] List the required ENV vars here.
  # - [ ] Check for each one how to retrieve them
  # - [ ] If a value exists, prompt the user to confirm it.
  # - [ ] There should be a built-in way to retrieve these values from Bitwarden.

  bitwarden_intro

  bitwarden_prompt="$(prompt-user -i "$(pending) " -yn "Would you like to use Bitwarden to retrieve your environment variables?")"

  if [ $bitwarden_prompt == "y" ]; then
    print-status -i ok "Using Bitwarden."
    ensure_brew_dependency jq 'bitwarden-cli:bw'
    load_env_data_from_bitwarden
  else
    print-status -i error "Not using Bitwarden."
    bitwarden_data_wizard
  fi
}

function load_env_data_from_bitwarden() {
  bitwarden_data_intro

  # Check if Bitwarden CLI is logged in
  $bitwarden_cmd unlock || exit 1

  BW_SESSION="$($bitwarden_cmd session-token)"

  # We repeat the check for the session var, because if we don't have it here
  # something went wrong.
  if [[ -n $BW_SESSION ]]; then
    print-status -n "Syncing with Bitwarden vaults ... "
    bw sync --quiet
    print-status -i ok "Bitwarden vaults synced."
  fi

  #OWNER_NAME="$(
    #echo $(bw list items --session "$BW_SESSION" |
        #jq -r '.[] | select(.identity != null) | .identity.firstName + " " + .identity.lastName'
    #) | fzf --prompt "Who are you? "
  #)"

  OWNER_NAME=$(prompt-user -i "$(pending) " -d "$OWNER_NAME" "Enter your first and last name: ")

  #GITHUB_EMAIL="$(
    #echo $(bw get item --session "$BW_SESSION" --search "Github" |
        #jq -r '.[] | select(.login.username != null) | .login.username'
    #) | fzf --prompt "Select the e-mail address you log into Github with: "
  #)"

  GITHUB_EMAIL=$(prompt-user -i "$(pending) " -d "$GITHUB_EMAIL" "Enter the e-mail address you log into Github with: ")

  print-status -n "Preparing data from vault(s) ... "
  owner_data=$(bw list items --session "$BW_SESSION" --search "$OWNER_NAME" | jq '.[] | select(.identity != null)')
  bitwarden_data=$(bw get item --session "$BW_SESSION" "$GITHUB_EMAIL")

  # TODO: At this point, if you don't have a good value for $OWNER_NAME,
  # you will see "Not found" and the script will break.
  # Catch the error after every bw call, or use fzf to get the right values.
  #if [[ $? -gt 0 ]]; then
    #clear_prompt_line
  #fi

  GITHUB_USERNAME="$(echo $bitwarden_data | jq -r '.fields[] | select(.name == "Public username").value')"
  GITHUB_PERSONAL_ACCESS_TOKEN=$(echo $bitwarden_data | jq -r '.fields[] | select(.name == "Personal access token") | .value')
  GPG_SIGNING_KEY=$(echo $owner_data | jq -r '.fields[] | select(.name == "GPG signing key").value')
  print-status -i ok "Vault data prepared."
}

function bitwarden_data_wizard() {
  fecho

  REPO_NAMESPACE=$(prompt-user -i "$(pending) " -d "${REPO_NAMESPACE:-$HOME/Repositories}" "Where do you keep your local Git(hub) repos? ")

  if [[ -z $OWNER_NAME ]]; then 
    OWNER_NAME=$(prompt-user -i "$(pending) " -d "$OWNER_NAME" "Enter your first and last name: ")
  fi

  if [[ -z $GITHUB_EMAIL ]]; then
    GITHUB_EMAIL=$(prompt-user -i "$(pending) " -d "$GITHUB_EMAIL" "Enter the email address you log into Github with: ")
  fi

  GITHUB_USERNAME=$(prompt-user -i "$(pending) " -d "${GITHUB_USERNAME}" "Enter your public Github username: ")

  GITHUB_PERSONAL_ACCESS_TOKEN=$(prompt-user -i "$(pending) " -d "$GITHUB_PERSONAL_ACCESS_TOKEN" "Enter your Github Personal access token: ")

  GPG_SIGNING_KEY=$(prompt-user -i "$(pending) " -d "$GPG_SIGNING_KEY" "Enter your GPG signing key: ")

  # Check if the REPO_NAMESPACE path exists, and create it if not.
  if [[ ! -d $REPO_NAMESPACE ]]; then
    print-status -n "Creating $REPO_NAMESPACE ... "
    # You want to use `grealpath` here to correctly resolve the tilde in the path
    # and prevent bash from creating a directory named "~". -.-
    #mkdir -p "$(grealpath $REPO_NAMESPACE)"
    print-status -i ok "Created $REPO_NAMESPACE."
  fi
}

salt_requirements() {
  salt_intro

  local pass=$(prompt-user -i "$(pending) " -m "Enter your desired password: ")
  local pass_confirmation=$(prompt-user -i "$(pending) " -m  "Confirm your entered password: ")

  if [[ -z $pass ]] || [[ -z $pass_confirmation ]] || [[ $pass != $pass_confirmation ]]; then
    utility bash cursor -p clear-up:8
    salt_requirements
    return
  fi

  # Generate a salt and encrypt it with the given password.
  echo $(openssl rand -base64 32 | utility misc encrypt -p "$pass") > "$DOTFILES_STATE_PATH/salt"

  utility bash cursor clear-up:2
  print-status -i ok "Salt successfully saved."
  fecho 
}

function write_env_files() {
  cat > "$env_file" <<EOF
# This file is generated by $DOTFILES_PATH/setup/env_wizard.
# If you add your own global ENV vars below, remember to backport them to that script.
OWNER_NAME="$OWNER_NAME"
REPO_NAMESPACE="$REPO_NAMESPACE"
DOTFILES_PATH="$DOTFILES_PATH"
DOTFILES_STATE_PATH="$DOTFILES_STATE_PATH"
GITHUB_EMAIL=$GITHUB_EMAIL
GITHUB_USERNAME=$GITHUB_USERNAME
GITHUB_PERSONAL_ACCESS_TOKEN=$GITHUB_PERSONAL_ACCESS_TOKEN
GPG_SIGNING_KEY=$GPG_SIGNING_KEY
EOF

  # Write to ~/.gitconfig.env so we can keep our gitconfig user-agnostic.
  gitconfig_env_file="$HOME/.gitconfig.env"
  cat > "$gitconfig_env_file" <<EOF
# This file is generated by $DOTFILES_PATH/setup/env_wizard.
# If you add your own global ENV vars below, remember to backport them to that script.
[user]
  name = "$GITHUB_USERNAME"
  email = "$GITHUB_EMAIL"
  signingkey = "$GPG_SIGNING_KEY"
EOF
}

function main() {
  intro

  proceed="$(prompt-user -c -i "$(pending) " "Press any key to continue ... ")"
  [[ -n $proceed ]] && utility bash cursor clear-up

  salt_requirements
  secrets_management_requirements
  #write_env_files

  print-status -i ok "All done!"

  fecho
  fecho "Environment variables written to these files:"
  fecho "  $gitconfig_env_file"
  fecho "  $env_file"
  fecho
  fecho "Please source ~/.bashrc or restart your shell to apply changes."
  fecho
  separator
}

main "$@"
