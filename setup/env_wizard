#!/usr/bin/env bash

# TODO: Would be better to switch most of my ENV vars I don't need in $PATH
# to live in a config/config.toml file or something.

# Derive the dotfiles' absolute path so we always have a sensible default for 
# the ~/.env file.
export DOTFILES_PATH=$(dirname "$(dirname $(realpath "$0"))")
export DOTFILES_STATE_PATH="${HOME}/.local/state/dots"

[[ -f $DOTFILES_PATH/bash/helpers.sh ]] && source $DOTFILES_PATH/bash/helpers.sh
trap 'clear && interrupt_handler' SIGINT

bitwarden() { utility misc bitwarden "$@"; }
cursor() { utility bash cursor "$@"; }
encrypt() { utility bash encrypt "$@"; }
decrypt() { utility bash decrypt "$@"; }
print-status() { utility bash print-status "$@" && box_border_right; }
prompt-user() { utility bash prompt-user "$@"; }
# TODO: I think this entire thing is worth extracting now o.O
# box-drawing characters taken from Wikipedia:
# https://en.wikipedia.org/wiki/Box-drawing_characters#Unix,_CP/M,_BBS

export W=80
export MARGIN=" "
#MARGIN=$(repeat $(expr $(expr $(tput cols) - $W) / 2) echo -n ".")
function box_top()       { printf "$MARGIN┌" && printf '%.s─' $(seq 1 ${1:-$((W - 2))}) && printf "┐\n"; }
function box_line()      { printf "%.s${2:-─}" $(seq 1 ${1:-$((W - 2))}); }
function box_separator() { printf "$MARGIN├$(box_line $((W - 2)))┤\n"; }
function box_print()     { printf "$MARGIN│ %-$((W - 4))s │\n" "$1"; }
function box_bottom()    { printf "$MARGIN└" && printf '%.s─' $(seq 1 ${1:-$((W - 2))}) && printf "┘\n"; }
function box_border_right() { cursor move-start move-up col:$((W + 1)) print:│\\n ; }

function box() {
  value="$1"

  if [[ ${#value} -gt 80 ]]; then
    # TODO: Implement a word wrap function.
    printf ""
  fi

  box_top
  box_print
  repeat box_print "$@" 
  box_print
  box_bottom
}


function intro() {
  box_top
  box_print
  box_print "This script will help you set up your environment variables."
  box_print "Press Enter to confirm suggested values."
  box_print "Press Ctrl + c at any time to abort."
  box_print
}

function setup_encryption_intro() {
  box_print
  box_separator
  box_print
  box_print "ENCRYPTION                                                       (part 1/4)"
  box_print
  box_print "Utility commands like \`encrypt\` require a password-protected salt."
  box_print
}

function setup_secrets_management_intro() {
  box_separator
  box_print
  box_print "SECRETS MANAGEMENT                                               (part 2/4)"
  box_print
  box_print "My various secrets and API keys are stored in Bitwarden."
  box_print "These dotfiles can retrieve them from your vault(s) using \`bw\`,"
  box_print "and keep them in ENV vars in $env_file."
  box_print
}

function setup_env_intro() {
  box_separator
  box_print
  box_print "ENVIRONMENT VARIABLES                                       (part 3/4)"
  box_print
  box_print "My various secrets and API keys are stored in Bitwarden."
  box_print "These dotfiles can retrieve them from your vault(s) using \`bw\`,"
  box_print "and keep them in ENV vars in $env_file."
  box_print
}

function bitwarden_intro() {
  box_print
  box_print "My various secrets and API keys are stored in Bitwarden."
  box_print "I built in support to retrieve and use them in these dotfiles."
  box_print "(NOTE: This does not use the Secrets Manager yet; it's still in beta."
  box_print
}

function bitwarden_data_intro() {
  box_print
  box_print "You need the following two items ready in Bitwarden:"
  box_print
  box_print "1. An item of the Identity type, containing your first and last name."
  box_print
  box_print "2. An item of the Login type, named \"Github\", containing:"
  box_print "   a. The 'Username' field entry (i.e. your Github e-mail address)"
  box_print "   b. A custom field entry named 'Public username'"
  box_print "   c. A custom field entry named 'Personal access token'"
  box_print 
}

function setup_encryption() {
  local looping=${1:-0}
  local icon="$(pending)"

  setup_encryption_intro

  if [[ ! -f "$DOTFILES_STATE_PATH/salt.enc" ]]; then
    [[ $looping -eq 1  ]] && icon="$(cross)"
    local pass=$(prompt-user -i "$icon " -m "Enter your desired password: ")
    local pass_confirmation=$(prompt-user -i "$(pending) " -m  "Confirm your entered password: ")

    if [[ ! -f "$DOTFILES_STATE_PATH/salt" ]]; then
      openssl rand -base64 32 > "$DOTFILES_STATE_PATH/salt"
    fi

    if [[ -z $pass ]] || [[ -z $pass_confirmation ]] || [[ $pass != $pass_confirmation ]]; then
      cursor -p clear-up:7
      setup_encryption 1
      return
    fi

    # Generate a salt and encrypt it with the given password.
    encrypt -f -p "$pass" -i "$DOTFILES_STATE_PATH/salt" -o "$DOTFILES_STATE_PATH/salt.enc"
    cursor clear-up:2
  fi

  print-status -i ok "Encrypted salt is ready."
  box_print 
}

function setup_secrets_management() {
  setup_secrets_management_intro

  bitwarden_prompt="$(prompt-user -i "$(pending) " -yn "Would you like to use Bitwarden to retrieve your secrets?")"

  if [ $bitwarden_prompt == "y" ]; then
    print-status -i ok "Using Bitwarden."
    #ensure_brew_dependency jq 'bitwarden-cli:bw'
    #load_env_data_from_bitwarden
    setup_bitwarden
  else
    print-status -i error "Not using Bitwarden."
  fi

  box_print
  box_separator
}

function setup_bitwarden() {
  # Check if Bitwarden CLI is logged in
  bitwarden unlock || exit 1
  BW_SESSION="$(bitwarden session-token)"

  # TODO: STOPPED HERE; CONTINUE
  return


  # We repeat the check for the session var, because if we don't have it here
  # something went wrong.
  if [[ -n $BW_SESSION ]]; then
    print-status -n "Syncing with Bitwarden vaults ... "
    bw sync --quiet
    print-status -i ok "Bitwarden vaults synced."
  fi

  #OWNER_NAME="$(
    #echo $(bw list items --session "$BW_SESSION" |
        #jq -r '.[] | select(.identity != null) | .identity.firstName + " " + .identity.lastName'
    #) | fzf --prompt "Who are you? "
  #)"

  OWNER_NAME=$(prompt-user -i "$(pending) " -d "$OWNER_NAME" "Enter your first and last name: ")

  #GITHUB_EMAIL="$(
    #echo $(bw get item --session "$BW_SESSION" --search "Github" |
        #jq -r '.[] | select(.login.username != null) | .login.username'
    #) | fzf --prompt "Select the e-mail address you log into Github with: "
  #)"

  GITHUB_EMAIL=$(prompt-user -i "$(pending) " -d "$GITHUB_EMAIL" "Enter the e-mail address you log into Github with: ")

  print-status -n "Preparing data from vault(s) ... "
  owner_data=$(bw list items --session "$BW_SESSION" --search "$OWNER_NAME" | jq '.[] | select(.identity != null)')
  bitwarden_data=$(bw get item --session "$BW_SESSION" "$GITHUB_EMAIL")

  # TODO: At this point, if you don't have a good value for $OWNER_NAME,
  # you will see "Not found" and the script will break.
  # Catch the error after every bw call, or use fzf to get the right values.
  #if [[ $? -gt 0 ]]; then
    #clear_prompt_line
  #fi

  GITHUB_USERNAME="$(echo $bitwarden_data | jq -r '.fields[] | select(.name == "Public username").value')"
  GITHUB_PERSONAL_ACCESS_TOKEN=$(echo $bitwarden_data | jq -r '.fields[] | select(.name == "Personal access token") | .value')
  print-status -i ok "Vault data prepared."
}

function setup_env() {
  # TODO: Check for Bitwarden
  bitwarden_data_intro

  if [[ -f $env_file ]]; then
    source "$env_file"
    print-status -i ok "Loaded environment variables from $env_file."
    box_print
  fi
}

function env_data_wizard() {
  box_print

  REPO_NAMESPACE=$(prompt-user -i "$(pending) " -d "${REPO_NAMESPACE:-$HOME/Repositories}" "Where do you keep your local Git(hub) repos? ")

  if [[ -z $OWNER_NAME ]]; then 
    OWNER_NAME=$(prompt-user -i "$(pending) " -d "$OWNER_NAME" "Enter your first and last name: ")
  fi

  if [[ -z $GITHUB_EMAIL ]]; then
    GITHUB_EMAIL=$(prompt-user -i "$(pending) " -d "$GITHUB_EMAIL" "Enter the email address you log into Github with: ")
  fi

  GITHUB_USERNAME=$(prompt-user -i "$(pending) " -d "${GITHUB_USERNAME}" "Enter your public Github username: ")

  GITHUB_PERSONAL_ACCESS_TOKEN=$(prompt-user -i "$(pending) " -d "$GITHUB_PERSONAL_ACCESS_TOKEN" "Enter your Github Personal access token: ")

  # Can be either a literal key, or a path to a key file.
  # TODO: Ask to load in an SSH key to set the path
  GIT_SIGNING_KEY=$(prompt-user -i "$(pending) " -d "$GIT_SIGNING_KEY" "Enter your Git signing key: ")

  # Check if the REPO_NAMESPACE path exists, and create it if not.
  if [[ ! -d $REPO_NAMESPACE ]]; then
    print-status -n "Creating $REPO_NAMESPACE ... "
    # You want to use `grealpath` here to correctly resolve the tilde in the path
    # and prevent bash from creating a directory named "~". -.-
    #mkdir -p "$(grealpath $REPO_NAMESPACE)"
    print-status -i ok "Created $REPO_NAMESPACE."
  fi
}

function write_env_files() {
  cat > "$env_file" <<EOF
# This file is generated by $DOTFILES_PATH/setup/env_wizard.
# If you add your own global ENV vars below, remember to backport them to that script.
OWNER_NAME="$OWNER_NAME"
REPO_NAMESPACE="$REPO_NAMESPACE"
DOTFILES_PATH="$DOTFILES_PATH"
DOTFILES_STATE_PATH="$DOTFILES_STATE_PATH"
GITHUB_EMAIL=$GITHUB_EMAIL
GITHUB_USERNAME=$GITHUB_USERNAME
GITHUB_PERSONAL_ACCESS_TOKEN=$GITHUB_PERSONAL_ACCESS_TOKEN
EOF

  # Write to ~/.gitconfig.env so we can keep our gitconfig user-agnostic.
  gitconfig_env_file="$HOME/.gitconfig.env"
  cat > "$gitconfig_env_file" <<EOF
# This file is generated by $DOTFILES_PATH/setup/env_wizard.
# If you add your own global ENV vars below, remember to backport them to that script.
[user]
  name = "$GITHUB_USERNAME"
  email = "$GITHUB_EMAIL"
  signingkey = "$GIT_SIGNING_KEY"
EOF
}

function main() {
  intro

  local bitwarden=0
  local env_file="${HOME}/.env"

  proceed="$(prompt-user -c -i "$(pending) " "Press any key to continue ... ")"
  [[ -n $proceed ]] && cursor move-start clear-up

  setup_encryption
  setup_secrets_management
  setup_env
  #write_env_files

  print-status -i ok "All done!"

  box_print
  box_print "Environment variables written to these files:"
  box_print "  $gitconfig_env_file"
  box_print "  $env_file"
  box_print
  box_print "Please source ~/.bashrc or restart your shell to apply changes."
  box_print
  box_bottom
}

main "$@"
