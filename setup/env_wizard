#!/usr/bin/env bash

# TODO: Would be better to switch most of my ENV vars I don't need in $PATH
# to live in a config/config.toml file or something.

# Derive the dotfiles' absolute path so we always have a sensible default for 
# the ~/.env file.
env_file="${HOME}/.env"
setup_path="$(dirname $(realpath "$0"))"
export DOTFILES_PATH=$(dirname $setup_path)
export DOTFILES_STATE_PATH="${HOME}/.local/state/dots"
bitwarden_cmd="$DOTFILES_PATH/bin/utilities/misc/bitwarden"

[[ -f $DOTFILES_PATH/bash/helpers.sh ]] && source $DOTFILES_PATH/bash/helpers.sh
trap 'clear && interrupt_handler' SIGINT

function print-status() {
  utility bash print-status "$@"
}

function separator() {
  printf "────¦"
  printf '%.s─' $(seq 6 $(tput cols))
}

function fecho() {
  printf "    ¦ %s" "$1"
}

function intro() {
  echo "    ¦"
  echo "    ¦ This script will help you set up your environment variables."
  echo "    ¦ Press Enter to confirm suggested values."
  echo "    ¦ Press Ctrl + c at any time to abort."
  echo "    ¦"
}

function salt_intro() {
  echo "    ¦"
  echo "    ¦ Some utility commands like encrypt/decrypt require a password-protected salt."
  echo "    ¦ Every time you log into your shell, you will be prompted for this password."
  echo "    ¦"
}

function bitwarden_data_intro() {
  echo "    ¦"
  echo "    ¦ Some utility commands like encrypt/decrypt require a password-protected salt."
  echo "    ¦ Every time you log into your shell, you will be prompted for this password."
  echo "    ¦"
}

function bitwarden_data_intro() {
  echo "    ¦"
  echo "    ¦ You need the following two items ready in Bitwarden:"
  echo "    ¦"
  echo "    ¦ 1. An item of the Identity type, containing your first and last name."
  echo "    ¦    a. A custom field entry on the Identity item named 'GPG signing key'"
  echo "    ¦"
  echo '    ¦ 2. An item of the Login type, named "Github", containing:'
  echo "    ¦    a. The Username login credential that matches your Github e-mail address"
  echo "    ¦    b. A custom field entry named 'Public username'"
  echo "    ¦    c. A custom field entry named 'Personal access token'"
  echo "    ¦"
}

function bitwarden_prompt() {
  printf "$(pending) "

  while true; do
    read -n1 -p "Would you like to use Bitwarden to retrieve your environment variables? (y/n) " bitwarden

    case $bitwarden in
      [Yy]* ) print-status -i ok "Using Bitwarden." && return 0;;
      [Nn]* ) print-status -i error "Not using Bitwarden." && return 1;;
      * ) print-status -n "Please answer `tput smul`Y`tput rmul`es or `tput smul`N`tput rmul`o. ";;
    esac
  done

  echo
}

function bitwarden_requirements() {
  if [[ -f $env_file ]]; then
    # TODO: This assumes all vars are accounted for with values.
    # Probably need to check every individual var instead.
    source "$env_file"
    print-status -p "$(fecho)" -i ok "Loaded environment variables from $env_file."
  else
    if bitwarden_prompt; then
      ensure_brew_dependency jq 'bitwarden-cli:bw'
      load_env_data_from_bitwarden
    fi
  fi

  fecho
  printf "\n\n"
  bitwarden_data_wizard
}

function load_env_data_from_bitwarden() {
  bitwarden_data_intro

  # Check if Bitwarden CLI is logged in
  $bitwarden_cmd unlock || exit 1

  BW_SESSION="$($bitwarden_cmd session-token)"

  # We repeat the check for the session var, because if we don't have it here
  # something went wrong.
  if [[ -n $BW_SESSION ]]; then
    print-status -n "Syncing with Bitwarden vaults ... "
    bw sync --quiet
    print-status -i ok "Bitwarden vaults synced."
  fi

  #OWNER_NAME="$(
    #echo $(bw list items --session "$BW_SESSION" |
        #jq -r '.[] | select(.identity != null) | .identity.firstName + " " + .identity.lastName'
    #) | fzf --prompt "Who are you? "
  #)"

  export OWNER_NAME=$(u bash prompt-user "OWNER_NAME" "Enter your first and last name" "$OWNER_NAME")
  clear_prompt_line

  #GITHUB_EMAIL="$(
    #echo $(bw get item --session "$BW_SESSION" --search "Github" |
        #jq -r '.[] | select(.login.username != null) | .login.username'
    #) | fzf --prompt "Select the e-mail address you log into Github with: "
  #)"

  export GITHUB_EMAIL=$(utility bash prompt-user -d "$GITHUB_EMAIL" "Enter the e-mail address you log into Github with")
  clear_prompt_line

  print-status -n "Preparing data from vault(s) ... "
  owner_data=$(bw list items --session "$BW_SESSION" --search "$OWNER_NAME" | jq '.[] | select(.identity != null)')
  bitwarden_data=$(bw get item --session "$BW_SESSION" "$GITHUB_EMAIL")

  # TODO: At this point, if you don't have a good value for $OWNER_NAME,
  # you will see "Not found" and the script will break.
  # Catch the error after every bw call, or use fzf to get the right values.
  #if [[ $? -gt 0 ]]; then
    #clear_prompt_line
  #fi

  GITHUB_USERNAME="$(echo $bitwarden_data | jq -r '.fields[] | select(.name == "Public username").value')"
  GITHUB_PERSONAL_ACCESS_TOKEN=$(echo $bitwarden_data | jq -r '.fields[] | select(.name == "Personal access token") | .value')
  GPG_SIGNING_KEY=$(echo $owner_data | jq -r '.fields[] | select(.name == "GPG signing key").value')
  print-status -i ok "Vault data prepared."
}

function bitwarden_data_wizard() {
  REPO_NAMESPACE=$(utility bash prompt-user -d "${REPO_NAMESPACE:-$HOME/Repositories}" "Where do you keep your local Git(hub) repos?")
  clear_prompt_line

  if [[ -z $OWNER_NAME ]]; then 
    OWNER_NAME=$(utility bash prompt-user -d "$OWNER_NAME" "Enter your first and last name")
    clear_prompt_line
  fi

  if [[ -z $GITHUB_EMAIL ]]; then
    GITHUB_EMAIL=$(utility bash prompt-user -d "$GITHUB_EMAIL" "Enter the email address you log into Github with")
    clear_prompt_line
  fi

  GITHUB_USERNAME=$(utility bash prompt-user -d "${GITHUB_USERNAME}" "Enter your public Github username")
  clear_prompt_line

  GITHUB_PERSONAL_ACCESS_TOKEN=$(utility bash prompt-user -d "$GITHUB_PERSONAL_ACCESS_TOKEN" "Enter your Github Personal access token")
  clear_prompt_line

  GPG_SIGNING_KEY=$(utility bash prompt-user -d "$GPG_SIGNING_KEY" "Enter your GPG signing key")
  clear_prompt_line

  # Check if the REPO_NAMESPACE path exists, and create it if not.
  if [[ ! -d $REPO_NAMESPACE ]]; then
    print-status -n "Creating $REPO_NAMESPACE ... "
    # You want to use `grealpath` here to correctly resolve the tilde in the path
    # and prevent bash from creating a directory named "~". -.-
    #mkdir -p "$(grealpath $REPO_NAMESPACE)"
    print-status -i ok "Created $REPO_NAMESPACE."
  fi
}

salt_requirements() {
  salt_intro

  local pass=$(utility bash prompt-user -m "Enter your desired password: ")
  echo
  local pass_confirmation=$(utility bash prompt-user -m  "Confirm your entered password: ")
  echo

  if [[ -z $pass ]] || [[ -z $pass_confirmation ]] || [[ $pass != $pass_confirmation ]]; then
    print-status --prefix "$(fecho)" -i error "Passwords do not match. Please try again."
    for i in {1..9}; do printf '\033[F\033[K'; done
    printf "\033[J"
    salt_requirements 1
    return
  fi

  # Generate a salt and encrypt it with the given password.
  echo $(openssl rand -base64 32 | utility misc encrypt -p "$pass") > "$DOTFILES_STATE_PATH/salt"

  for i in {1..4}; do printf '\033[F\033[K'; done
  print-status -p "$(fecho)" -i ok "Salt successfully saved."
  fecho

  echo
  separator
  echo
}

function write_env_files() {
  cat > "$env_file" <<EOF
# This file is generated by $DOTFILES_PATH/setup/env_wizard.
# If you add your own global ENV vars below, remember to backport them to that script.
OWNER_NAME="$OWNER_NAME"
REPO_NAMESPACE="$REPO_NAMESPACE"
DOTFILES_PATH="$DOTFILES_PATH"
DOTFILES_STATE_PATH="$DOTFILES_STATE_PATH"
GITHUB_EMAIL=$GITHUB_EMAIL
GITHUB_USERNAME=$GITHUB_USERNAME
GITHUB_PERSONAL_ACCESS_TOKEN=$GITHUB_PERSONAL_ACCESS_TOKEN
GPG_SIGNING_KEY=$GPG_SIGNING_KEY
EOF

  # Write to ~/.gitconfig.env so we can keep our gitconfig user-agnostic.
  gitconfig_env_file="$HOME/.gitconfig.env"
  cat > "$gitconfig_env_file" <<EOF
# This file is generated by $DOTFILES_PATH/setup/env_wizard.
# If you add your own global ENV vars below, remember to backport them to that script.
[user]
  name = "$GITHUB_USERNAME"
  email = "$GITHUB_EMAIL"
  signingkey = "$GPG_SIGNING_KEY"
EOF
}

function main() {
  intro

  while true; do
    read -n1 -p "Press any key to continue ... " ok
    if [[ -n $ok ]]; then 
      clear_line && separator
      break
    fi
  done

  salt_requirements
  bitwarden_requirements
  #write_env_files

  print-status -i ok "All done!"
  echo
  echo "Environment variables written to these files:"
  echo "  $gitconfig_env_file"
  echo "  $env_file"
  echo
  echo "Please source ~/.bashrc or restart your shell to apply changes."
  echo
}

main "$@"
