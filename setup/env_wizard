#!/usr/bin/env bash

# TODO: Would be better to switch most of my ENV vars I don't need in $PATH
# to live in a config/config.toml file or something.

# Gracefully handle Ctrl-C to get out of this thing.
handle_interrupt() {
  if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    printf "\nAborted.\n"
    exit 1
  fi
}
trap handle_interrupt SIGINT

# Function to prompt for input with a default value
prompt() {
  local var_name="$1"
  local prompt_text="$2"
  local default_value="$3"
  local input
  read -rp "${prompt_text} [${default_value}]: " input
  echo "${input:-$default_value}"
}

ask_for_bitwarden() {
  read -n1 -p "Would you like to use Bitwarden to retrieve your environment variables? (y/n) " bitwarden
  echo ""
  case $bitwarden in
    [Yy]* ) return 0;;
    [Nn]* ) return 1;;
    * ) printf "\nPlease answer `tput smul`Y`tput rmul`es or `tput smul`N`tput rmul`o.\n";;
  esac
}

echo ""
echo "###"
echo "### This script will help you set up your environment variables."
echo "### Press Enter to confirm suggested values."
echo "### Press Ctrl + c at any time to abort."
echo "###"
echo ""

# Derive the dotfiles' absolute path so we always have a sensible default for 
# the ~/.env file.
setup_path="$(dirname $(realpath "$0"))"
dotfiles_derived_path=$(dirname $setup_path)
dotfiles_state_path="${HOME}/.local/state/dots"
env_file="${HOME}/.env"

# Load existing .env if available
if [[ -f $env_file ]]; then
  # TODO: This assumes all vars are accounted for with values.
  # Probably need to check every individual var instead.
  source "$env_file"
  echo "Loaded existing environment variables from $env_file."
else
  if ask_for_bitwarden; then
    # Make sure we have the necessary tools in our environment.
    [[ ! `command -v jq` ]] && brew install jq
    [[ ! `command -v bw` ]] && brew install bitwarden-cli

    echo ""
    echo "###"
    echo "### You need the following two items ready in Bitwarden:"
    echo "###"
    echo "### 1. An item of the Identity type, named after your full name, containing:"
    echo "###    a A custom field entry named 'GPG signing key'"
    echo "###"
    echo '### 2. An item of the Login type, named "Github", containing:'
    echo '###    a The Username login credential that matches your Github e-mail address'
    echo "###    b A custom field entry named 'Public username'"
    echo "###    c A custom field entry named 'Github API Token'"
    echo "###"
    echo ""

    # Check if Bitwarden CLI is logged in
    source $setup_path/unlock_bw || exit 1

    # We repeat the check for the session var, because if we don't have it here
    # something went wrong.
    if [[ -z $BW_SESSION ]]; then
      echo "Bitwarden unlock unsuccessful, proceeding without Bitwarden ..."
    else
      printf "Syncing with Bitwarden vaults ... "
      bw sync
      echo ""
    fi

    OWNER_NAME=$(prompt "OWNER_NAME" "Enter your first and last name" "")
    GITHUB_EMAIL=$(prompt "GITHUB_EMAIL" "Enter the email address you log into Github with" "")

    printf "Fetching Bitwarden data ... "
    owner_data=$(bw list items --search "$OWNER_NAME" | jq '.[] | select(.identity != null)')
    bitwarden_data=$(bw get item "$GITHUB_EMAIL")

    GITHUB_USERNAME="$(echo $bitwarden_data | jq -r '.fields[] | select(.name == "Public username").value')"
    GITHUB_PERSONAL_ACCESS_TOKEN=$(echo $bitwarden_data | jq -r '.fields[] | select(.name == "Github API Token") | .value')
    GPG_SIGNING_KEY=$(echo $owner_data | jq -r '.fields[] | select(.name == "GPG signing key").value')
    printf "OK!\n\n"
  else
    echo "Skipping Bitwarden."
  fi
fi

# Present the rest of the data to confirm.
REPO_NAMESPACE=$(prompt "REPO_NAMESPACE" "Where do you keep your local Git(hub) repos?" "${REPO_NAMESPACE:-$HOME/Repositories}")
[[ -z $OWNER_NAME ]] && OWNER_NAME=$(prompt "OWNER_NAME" "Enter your first and last name" "")
[[ -z $GITHUB_EMAIL ]] && GITHUB_EMAIL=$(prompt "GITHUB_EMAIL" "Enter the email address you log into Github with" "")
GITHUB_USERNAME=$(prompt "GITHUB_USERNAME" "Enter your public Github username" "${GITHUB_USERNAME}")
GITHUB_PERSONAL_ACCESS_TOKEN=$(prompt "GITHUB_PERSONAL_ACCESS_TOKEN" "Enter your Github API Token" "${GITHUB_PERSONAL_ACCESS_TOKEN}")
GPG_SIGNING_KEY=$(prompt "GPG_SIGNING_KEY" "Enter your GPG signing key" "${GPG_SIGNING_KEY}")

# Check if the REPO_NAMESPACE path exists, and create it if not.
if [[ ! -d $REPO_NAMESPACE ]]; then
  printf "\n$REPO_NAMESPACE does not exist yet. Creating ... "
  # You want to use `grealpath` here to correctly resolve the tilde in the path
  # and prevent bash from creating a directory named "~". -.-
  mkdir -p "$(grealpath $REPO_NAMESPACE)"
  printf "OK!\n"
fi

# Write to .env
cat > "$env_file" <<EOF
# This file is generated by $dotfiles_derived_path/setup/env_wizard.
# If you add your own global ENV vars below, remember to backport them to that script.
OWNER_NAME="$OWNER_NAME"
REPO_NAMESPACE="$(grealpath -m "${REPO_NAMESPACE/#\~/$HOME}")"
DOTFILES_PATH="$dotfiles_derived_path"
DOTFILES_STATE_PATH="$(grealpath -m "${dotfiles_state_path/#\~/$HOME}")"
GITHUB_EMAIL=$GITHUB_EMAIL
GITHUB_USERNAME=$GITHUB_USERNAME
GITHUB_PERSONAL_ACCESS_TOKEN=$GITHUB_PERSONAL_ACCESS_TOKEN
GPG_SIGNING_KEY=$GPG_SIGNING_KEY
EOF

# Write to ~/.gitconfig.env so we can keep our gitconfig user-agnostic.
gitconfig_env_file="$HOME/.gitconfig.env"
cat > "$gitconfig_env_file" <<EOF
# This file is generated by $dotfiles_derived_path/setup/env_wizard.
# If you add your own global ENV vars below, remember to backport them to that script.
[user]
  name = "$GITHUB_USERNAME"
  email = "$GITHUB_EMAIL"
  signingkey = "$GPG_SIGNING_KEY"
EOF

# CTA to source the bash ENV.
printf "\nEnvironment variables written to these files:\n"
echo   "  $gitconfig_env_file"
printf "  $env_file\n\n"
echo "Please source ~/.bashrc or restart your shell to apply changes."
