#!/bin/bash

function lowercase()
{
  if [ -n "$1" ]; then
    echo "$1" | tr "[:upper:]" "[:lower:]"
  else
    cat - | tr "[:upper:]" "[:lower:]"
  fi
}

# Command used to test rest services that are under development.
curlrest()
{
  method=$1
  url=$2
  parameters=$3

  if [[ "$method" == "" ]] || [[ "$url" == "" ]]
  then
    echo "usage: curlrest <method> <url> <*parameters>"
  else
    if [[ "$parameters" != "" ]]
    then
      parameters="--data-urlencode $(echo $parameters | xargs | sed 's/&/ --data-urlencode /g')"
    fi

    curl -v --globoff --get -X$method $url $parameters
    echo ""
  fi
}

# Returns the active git branch - this is used in rewrite_prompt().
git_branch()
{
  git branch --no-color 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}

git_delete_new_files()
{
  for file in $(git st | grep '??' | awk '{print substr($0, 4)}'); do rm -r $file; done
}

# Get a list of all filesizes in the current folder ("du -sh *" for files).
get_filesizes()
{
  ls -laSh $1 | grep -v ^d | awk '{print $5 "\t" $9}'
}

# Recursively moves all files matching the search query to the chosen directory.
move_files()
{
  search=$1
  destination=$2

  if [[ "$search" == "" ]] || [[ "$destination" == "" ]]
  then
    echo "usage: move_files <search> <destination>"
  else
    find . -type f -name "$search" -exec mv -fv '{}' "$destination" ';'
  fi
}

# Drops all tables in a specified MySQL database.
mysql_drop_all_tables()
{
  user=$1
  database=$2

  if [[ "$user" == "" ]] || [[ "$database" == "" ]]
  then
    echo "usage: mysql_drop_all_tables <user> <database>"
  else
    mysqldump -u $user -p $database --add-drop-table --no-data | grep ^DROP | mysql -u $user -p $database
  fi
}

# Replaces a local mysql database with the specified one.
mysql_replace()
{
  database=$1
  sql_file=$2

  if [[ "$database" == "" ]] || [[ "$sql_file" == "" ]]
  then
    echo "usage: mysql_replace <database> <sql_file>"
  else
    echo "Dropping and re-creating database '$database'"
    mysql $database -e "drop database $database; create database $database;"

    echo "Importing $sql_file ..."
    mysql $database < $sql_file

    echo "Done."
  fi
}

# Returns information on LOC added/removed for a given git log range and an
# optional author.
git_loc()
{
  range=$1
  author=$2

  git log -$1 --author="$2" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc }' -
}

# Syncs git production and staging branch with master.
git_merge()
{
  source_branch=$1
  target_branch=$2

  if [[ $target_branch == '' ]]; then
    target_branch='master'
  fi

  if [[ $source_branch == '' ]];
  then
    echo "usage: git_merge <source_branch> '<*target_branch>'"
  else
    git push origin $source_branch && \
      git checkout $target_branch && git merge $source_branch && git push origin $target_branch
    git checkout $source_branch
  fi
}

git_pick_latest_commit()
{
  source_branch=$1
  target_branch=$2

  if [[ $target_branch == '' ]]; then
    target_branch='master'
  fi

  if [[ $source_branch == '' ]];
  then
    echo "usage: git_pick_latest_commit <source_branch> '<*target_branch>'"
  else
    git checkout $source_branch
    hash=$(git rev-parse head)
    git checkout $target_branch && git cherry-pick $hash && git push origin $target_branch
    git checkout $source_branch
  fi
}

# Attempts to recursively find a match for a given string in the given file(s).
search()
{
  string=$1
  files=$2

  if [[ $string == '' ]];
  then
    echo "usage: search <search> '<*glob_expansion>'"
    echo "	Make sure the glob expansion is in quotes!"
  else
    if [[ $files == '' ]];
    then
      find . -type f -exec grep -l "$string" {} +
    else
      find . -type f -name "$files" -exec grep -l "$string" {} +
    fi
  fi
}

# Attempts to recursively search the given range of files for a given perl-compatible regex and replace with a given value.
search_and_replace()
{
  search=$1
  replace=$2
  files=$3

  if [[ $search == '' ]] || [[ $replace == '' ]];
  then
    echo "usage: search_and_replace <search> <replace <*glob_expansion>"
    echo "	Make sure the glob expansion is in quotes!"
  else
    if [[ $files == '' ]];
    then
      sudo find . -type f -exec perl -pi -e "s/$search/$replace/g" {} \;
    else
      sudo find . -type f -name "$files" -exec perl -pi -e "s/$search/$replace/g" {} \;
    fi
  fi
}

# Export all changed files between the given revision and HEAD, to a given location.
svn_export_changed_files()
{
  tarfile=$1
  start_rev=$2
  end_rev=$3

  if [[ "$end_rev" == "" ]]; then
    end_rev='HEAD'
  fi

  if [[ "$tarfile" == "" ]] || [[ "$start_rev" == "" ]]
  then
    echo "usage: svn_export_changed_files <tarfile> <start_rev> <*end_rev>"
  else
    svn diff -r "$start_rev":"$end_rev" --summarize |
    awk '{if ($1 != "D") print $2}'|
    xargs  -I {} tar -rvf "$tarfile" {}
  fi
}

# Compatible secure copy command for Vagrant boxes.
vscp()
{
  [ ! $(pgrep -n "VBoxHeadless") ] && echo "No vagrant VM is running" && return;

  OPTIONS=`vagrant ssh-config | awk -v ORS=' ' ' {print "-o " $1 "=" $2}'`
  scp ${OPTIONS} "$@" || echo "Transfer failed. Did you use 'default:' as the target?"
}

# As taken from http://owen.cymru/sf-a-quick-way-to-search-for-some-thing-in-bash-and-edit-it-with-vim-2/
sf() {
  if [ "$#" -lt 1 ]; then echo "Supply string to search for!"; return 1; fi
  printf -v search "%q" "$*"
  include="yml,js,json,php,md,styl,pug,jade,html,config,py,cpp,c,go,hs,rb,conf,fa,lst"
  exclude=".config,.git,node_modules,vendor,build,builds,yarn.lock,*.sty,*.bst,*.coffee,dist"
  rg_command='rg --column --line-number --no-heading --fixed-strings --ignore-case --no-ignore --hidden --follow --color "always" -g "*.{'$include'}" -g "!{'$exclude'}/*"'
  files=`eval $rg_command $search | fzf --ansi --multi --reverse | awk -F ':' '{print $1":"$2":"$3}'`
  [[ -n "$files" ]] && ${EDITOR:-vim} $files
}
